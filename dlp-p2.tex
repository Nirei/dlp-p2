% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt,captions=nooneline,DIV=14, parskip=full]{scrartcl}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
%\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
%\pagestyle{fancy} % options: empty , plain , fancy
%\renewcommand{\headrulewidth}{0pt} % customise the layout...
%\lhead{}\chead{}\rhead{}
%\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%%% VERY CUSTOM CUSTOM CUSTOMIZATIONS %%%
\usepackage{sectsty}
\sectionfont{\rmfamily}
\subsectionfont{\rmfamily}

\usepackage{datetime}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{relsize}

\usepackage[labelfont=bf]{caption}
\setcapwidth[c]{.8\textwidth}
\setcapindent{0pt}
\addtokomafont{caption}{\centering}

\usepackage{listings}
\usepackage{qtree}
\usepackage{hyperref}
\usepackage[spanish]{babel}
\usepackage{csquotes}

\setlist[itemize]{label={$\bullet$}}

\newcommand{\vctilde}{\raisebox{0.5ex}{\texttildelow}}

\title{Deseño de Linguaxes de Programación}
\subtitle{Programación Lógica}
\author{Rodríguez Arias, Alejandro\\
	\texttt{alejandro.rodriguez.arias@udc.es}
	\and Bouzas Quiroga, Jacobo\\
	\texttt{jacobo.bouzas.quiroga@udc.es}}

\makeatletter
\@ifpackagelater{scrbase}{2014/12/12}{}{\def\scr@startsection{\@startsection}}
\makeatother

% fecha
\newdate{release}{26}{10}{2017}
\date{\displaydate{release}}

%%% The "real" document content comes below...
\begin{document}
\maketitle
\clearpage
\tableofcontents
\clearpage

\section{Introducción}
\label{sec:intro}

El presente trabajo tratará de ofrecer una aproximación al paradigma de la programación lógica y los diferentes lenguajes de programación que se encuadran en él, dando una perspectiva de las particularidades de este tipo de lenguajes respecto a los de otros paradigmas y ofreciendo una visión comparativa de las características propias de cada uno de los lenguajes estudiados.

La programación lógica, en su forma actual, surje alrededor de la década de los 70 en el marco del debate entre representaciones procedurales y declarativas del conocimiento en Inteligencia Artificial. La programación lógica se basa en la lógica formal.

Un programa en este paradigma se expresa como una serie de hechos y reglas que representan las relaciones entre ellos. De este modo, al escribir un algoritmo en estos lenguajes, no es necesario expresar el componente de control. El flujo del programa, el orden en que se ejecutan las instrucciones, se decidirá de forma automática y por tanto, la programación lógica es un subconjunto del paradigma de la programación declarativa.

La expresión de programas como una serie de cláusulas lógicas encuentra su utilidad fundamental en varios dominios en los que la lógica se presenta como la expresión natural de los problemas a abordar. Algunos de estos dominios son el razonamiento automático, tanto para la demostración automática de teoremas y la verificación formal como para la construcción de sistemas expertos; o el reconocimiento del lenguaje natural.

La programación lógica abarca varios tipos de lógicas, útiles en diferentes tipos de problemas. Además de la lógica proposicional y de primer orden, existen implementaciones de lógica difusa y lógica modal, como la temporal, para trabajar con la ambigüedad semántica propia de los lenguajes humanos o lógicas no monotónicas, para razonar bajo incertidumbre o información incompleta.

Los lenguajes elegidos en este trabajo para ejemplificar los diferentes usos de la programación lógica serán Prolog, para el caso más general, Datalog, como ejemplo de un lenguaje orientado a la consulta de bases de conocimientos, Maude system como ejemplo de sistema de reescritura y Clingo para el enfoque de programación de conjunto-respuesta (answer set programming).

El resto del trabajo está estructurado como sigue. La sección~\ref{sec:alt-logic} es una brevísima introducción a la lógica matemática y algunas lógicas alternativas a la usual lógica de predicados, que incorporan artefactos adecuados para el razonamiento en dominios en los que la lógica estándar se queda corta. En la sección~\ref{sec:prolog} introducimos el lenguaje Prolog, diseccionando su funcionamiento y características y comentando por encima algunas extensiones populares. La sección~\ref{sec:alt-prolog} comenta varios lenguajes de programación lógica alternativos orientados a distintos dominios y finalmente, la sección~\ref{sec:domains} examina los dominios de aplicación más frecuentes para la programación lógica y presenta algunos ejemplos de casos de uso reales desarrollados en este paradigma.

\section{Lógicas alternativas}
\label{sec:alt-logic}

\subsection{Lógica proposicional}

La lógica proposicional, o lógica de orden cero, es un sistema formal en el que sus elementos más simples son variables proposicionales cuyo ``significado'' no es importante, solo interesa su valor de verdad (\textquote{verdadero} o \textquote{falso}).

Las preposiciones están conectadas mediante conectivas lógicas que son tratadas como funciones de verdad; es decir, como funciones que toman conjuntos de valores de verdad y devuelven, también, valores de verdad. Por ejemplo, la conectiva \textquote{y} es una función que devolverá \textquote{verdadero} cuando tome dos valores de verdad verdaderos y, en el resto de casos, devolverá \textquote{falso}. La diferencia entre los distintos conectores lógicos es el valor de verdad devuelto según las combinaciones de valores que recibe.

\subsection{Lógica de predicados}

La lógica de predicados, o lógica de primer orden, aumenta la capacidad de expresión de la lógica proposicional. Un predicado es una expresión lingüística que puede conectarse con una o varias expresiones para formar una oración, pero para la lógica de predicados es una función que recibe expresiones como argumentos. La figura \ref{fig:predicados} muestra algunas oraciones en lenguaje natural y su correspondencia en lógica de predicados.

\begin{figure}[h]
\begin{itemize}
\item \textquote{Claire es una gata} $ \to Gata(Claire) $
\item \textquote{Juan juega con Lorena} $ \to Juega(Juan,Lorena) $
\end{itemize}
\caption{Ejemplos de predicados}
\label{fig:predicados}
\end{figure}

Existen constantes de individuos que hacen referencia a entidades determinadas y variables de individuo que no tienen referencias determinadas; por tanto, su referencia varía con el contexto (figura \ref{fig:constantes}). Los cuantificadores son operadores sobre conjuntos de individuos que indican que una condición se verifica, por ejemplo: los cuantificadores universales y existenciales. Los predicados también pueden conectarse con las conectivas de la lógica proposicional.

\begin{figure}[h]
\begin{itemize}
\item Rico(Juan)
\item Rico(x)
\end{itemize}
\caption{Ejemplos de constantes y variables}
\label{fig:constantes}
\end{figure}

\subsection{Lógica no monotónica}

Los sistemas lógicos tradicionales tienen una relación de consecuencia monotónica; es decir, las nuevas fórmulas añadidas a una teoría no reducen el número de consecuencias (lo conocido no se ve modificado por el nuevo conocimiento). Esto impide trabajar con razonamientos por incertidumbre, probabilidad o la contradicción de creencias. La lógica no monotónica permite trabajar con estos criterios, ya que el nuevo conocimiento puede contradecir al viejo y, por tanto, reducirlo. Esto permite suponer hechos y modifcarlos cuando se tiene el conocimiento.

\subsection{Lógica modal}

La lógica modal añade las expresiones «es necesario que» y «es posible que» a la lógica de predicados. Estas expresiones califican la verdad de los juicios. Extensiones de la lógica modal añaden nuevas expresiones para calificar, como la lógica temporal, en la que el valor de la verdad de las expresiones es dependiente del tiempo; o la deóntica, que agrega la lógica de las normas.

\section{Prolog}
\label{sec:prolog}

El lenguaje de programación lógica más destacable es Prolog. Prolog fue creado por Alain Colmerauer y Phillippe Roussel a principios de los 70. Se trata de un lenguaje de programación lógica de propósito general cuya finalidad original era realizar procesamiento de lenguaje natural para el idioma francés.

\subsection{Cláusulas de Horn}
\label{subsec:horn}
El Prolog puro estaba originalmente restringido al uso de cierto tipo de fórmulas lógicas conocidas como cláusulas de Horn, esto es, implicaciones lógicas con un único consecuente.

\begin{figure}[h]
{\Large{\[ ( p \land q \land r ) \to s \]}}%
\caption{Cláusula de Horn en forma de implicación lógica. A la derecha encontramos una única variable.}
\label{fig:horn}
\end{figure}

La particularidad de estas cláusulas es que expresan una relación de causalidad entre los antecedentes y el consecuente, permitiendo demostrar la veracidad lógica del consecuente si se verifica cada uno de los antecedentes. En el ejemplo de la figura~\ref{fig:horn} $ s $ se cumple si lo hacen $ p $, $ q $ y $r $.

Programar en Prolog implica definir en primer lugar una base de hechos, que pueden ser átomos o proposiciones sobre estos, y reglas, las mencionadas cláusulas de Horn. Un átomo es un nombre definido en Prolog que no referencia ningún otro valor y sin significado propio, por ejemplo carlos, 'Pato' o 'universidade da Coruña'. Un ejemplo de una base de conocimiento se presenta en la figura~\ref{fig:knowledge}.

\begin{figure}[h]
\lstset{language=Prolog}
\begin{lstlisting}[frame=single]
% atomo victor: victor existe
victor.
% victor es alto
alto(victor).
% si llueve (antecedente), esta mojado (consecuente)
mojado :- llueve.
% si el dia X es lluvioso y soleado, habra arcoiris
arcoiris(X) :- lluvioso(X), soleado(X).	
\end{lstlisting} 
\caption{Definición de hechos atómicos, proposiciones y reglas en Prolog.}
\label{fig:knowledge}
\end{figure}

Una vez definida esta base de conocimiento, es posible plantear cuestiones sobre la misma al intérprete de Prolog. Las figuras \ref{fig:basehechos} y \ref{fig:queries} presentan ejemplos de ejecución de consultas sobre una base de hechos de Prolog.

\begin{figure}[p]
\lstset{language=Prolog}
\begin{lstlisting}[frame=single]
% base de hechos

% mujeres
mujer(sara).
mujer(selena).
mujer(silvia).
mujer(sonia).
mujer(susana).

% varones
hombre(jaime).
hombre(jeronimo).
hombre(jimeno).
hombre(jorge).
hombre(julian).

% parentescos explicitos: padres(hijo, progenitor1, progenitor2)
padres(susana, jaime, sara).
padres(julian, jeronimo, selena).
padres(silvia, julian, susana).
padres(jimeno, jorge, sonia).

% parentescos derivados (logicamente deductibles)
hija(X,Y) :- mujer(X), padres(X,Y,_).
hija(X,Y) :- mujer(X), padres(X,_,Y).
hijo(X,Y) :- hombre(X), padres(X,Y,_).
hijo(X,Y) :- hombre(X), padres(X,_,Y).
abuelx(X,Z) :- padres(Z,Y,_), padres(Y,X,_).
abuelx(X,Z) :- padres(Z,_,Y), padres(Y,X,_).
abuelx(X,Z) :- padres(Z,Y,_), padres(Y,_,X).
abuelx(X,Z) :- padres(Z,_,Y), padres(Y,_,X).
abuelo(X,Y) :- hombre(X), abuelx(X,Y).
abuela(X,Y) :- mujer(X), abuelx(X,Y).
\end{lstlisting} 
\caption{Definición de una base de hechos.}
\label{fig:basehechos}
\end{figure}

\begin{figure}[p]
\lstset{language=Prolog}
\begin{lstlisting}[frame=single]
% query: quien es abuela de silvia?
?- abuela(Abuela, silvia).
Abuela = sara ;
Abuela = selena ;
false.

% query: es jimeno hijo de susana?
?- hijo(jimeno, susana).
false.

% query: de quien es hijo jimeno?
?- hijo(jimeno, Progenitor).
Progenitor = jorge ;
Progenitor = sonia ;
false.

query: que hijos varones tiene selena?
?- hijo(Hijo, selena).
Hijo = julian.
\end{lstlisting} 
\caption{Consultas sobre la base de hechos.}
\label{fig:queries}
\end{figure}

\subsection{Unificación y backtracking}

La ejecución de código en Prolog se guía por dos mecanismos, la unificación y el backtracking. Mediante la unificación de una cláusula se determinan los objetivos, las condiciones que forman el antecedente. Cada objetivo especifica un conjunto de cláusulas que podrían verificarlo, estas cláusulas se denominan puntos de elección. Si, tras su ejecución, uno de los puntos de elección prueba ser falso, se deshace la ejecución y se selecciona el siguiente punto de elección. Este proceso, denominado backtracking, se repite hasta que una de estas cláusulas resulte ser cierta o todos los puntos de elección resultan falsos.

\subsection{Prolog como lenguaje de programación}
Prolog provee un sistema de tipos dinámico. Estrictamente hablando, el único tipo considerado en Prolog es el término, que puede representar constantes, variables o valores compuestos, cláusulas incluídas. El estándar de prolog divide las constantes en varios subtipos para restringir el uso de distintas operaciones a los datos correctos, a saber números, que pueden ser de punto flotante o enteros, y átomos, los valores simbólicos introducidos en la sección \ref{subsec:horn}

Prolog trabaja únicamente con dos ``scopes'' posibles. Uno global, el de la base de reglas, accesible desde cualquier punto del programa y desde la línea de comandos del intérprete, y otro local a la cláusula en la que se llama un nombre.

A nivel de estructuras de datos, Prolog introduce listas recursivas, a la manera de Lisp; parejas de elementos y listas asociativas, implementadas con árboles binarios balanceados.

\section{Alternativas a Prolog}
\label{sec:alt-prolog}
lolol

\subsection{Maude System}
lol

\subsection{Datalog}
Datalog es un subconjunto del lenguaje Prolog empleado como lenguaje de consulta en bases de datos deductivas. A este efecto, Datalog restringe varias de las características de Prolog con el fin de explotar mejores algoritmos de evaluación de estas consultas.

\begin{enumerate}
\item Variables negadas en el cuerpo de una cláusula deben aparecer también sin negar en la propia cláusula.
\item Cualquier variable en la cabeza de una cláusula debe figurar también, sin negar, en el cuerpo de la misma.
\item Solo términos simples pueden aparecer como consecuente (cabecera) de una cláusula.
\item No exite operador de corte para interrumpir la ejecución de una consulta en determinado punto.
\end{enumerate}

\begin{figure}[h]
\lstset{language=Prolog}
\begin{lstlisting}[frame=single]
% permitido en datalog
p(a) :- q(a), not r(a).
p(a, b, c) :- q(a), r(b), s(c).
p (a, b).

% prohibido en datalog
p(a) :- not r(a).		% restriccion 1
p(a, b, c) :- r(b), s(c).	% restriccion 2
r(p(a, b), q(a, b)).		% restriccion 3

\end{lstlisting} 
\caption{Restricciones de Datalog ejemplificadas.}
\label{fig:restriccionesdatalog}
\end{figure}

Debido a estas restricciones Datalog no es Turing-completo, pero sí es puramente declarativo. La ausencia de un operador de corte, junto con la independencia del orden de declaración de las cláusulas, tiene como consecuencia la completa abstracción del control de flujo en la ejecución de consultas de Datalog. Otra propiedad interesante derivada de las restricciones de Datalog es que la ejecución siempre se puede realizar de forma bidireccional.

Datalog goza de cierta popularidad a día de hoy. Existen proyectos, tanto de software libre como comercial/privativo, que lo utilizan como lenguaje para numerosas tareas relacionadas con la consulta de bases de conocimiento. Entre los más reseñables encontramos Datomic, una base de datos transaccional y distribuída construída sobre Clojure y Datalog; SociaLite, un dialecto de Datalog de alto rendimiento para análisis de grafos en minería de datos diseñado en la universidad de Stanford; SecPAL, un lenguaje de políticas de seguridad de Microsoft Research y una amplia gama de dialectos con diferentes adiciones al lenguaje original.

\subsection{Clingo}
lol

\section{Dominios de aplicación}
lol
\end{document}